// Generated by gourd (version 0.4dev)
// Generated at 2016/04/16 14:33:18 (+0800)
// Note: If you want to re-generate this file in the future,
//       do not change it.

package oauth2

import (
	"github.com/go-kit/kit/log"
	"github.com/gourd/kit/store"
	"github.com/gourd/kit/store/upperio"
	"github.com/satori/go.uuid"

	"encoding/base64"
	"strings"

	"fmt"
	"io/ioutil"
	"upper.io/db"
)

// ClientStoreProvider implements store.Provider interface
// provides raw ClientStore
func ClientStoreProvider(sess interface{}) (s store.Store, err error) {

	var dbSess db.Database
	var ok bool

	logger := log.NewLogfmtLogger(ioutil.Discard)

	if dbSess, ok = sess.(db.Database); !ok {
		err = fmt.Errorf("expected db.Database in sess, got %#v", sess)
		return
	}

	// define store and return
	s = &ClientStore{dbSess, logger}
	return
}

// ClientStore serves generic CURD for type Client
// Generated by gourd CLI tool
type ClientStore struct {
	Db     db.Database
	logger log.Logger
}

// Create a Client in the database, of the parent
func (s *ClientStore) Create(
	cond store.Conds, ep store.EntityPtr) (err error) {

	// get collection
	coll, err := s.Coll()
	if err != nil {
		return
	}

	// apply random uuid string to string id

	uid := uuid.NewV4()
	e := ep.(*Client)
	e.ID = strings.TrimRight(base64.URLEncoding.EncodeToString(uid[:]), "=")

	// Marshal the item, if possible
	// (quick fix for upperio problem with db.Marshaler)
	if me, ok := ep.(db.Marshaler); ok {
		ep, err = me.MarshalDB()
		if err != nil {
			return
		}
	}

	// add the entity to collection

	_, err = coll.Append(ep)

	if err != nil {
		err = s.errorf("Error creating Client: %s", err.Error())
		return
	}

	return
}

// Search a Client by its condition(s)
func (s *ClientStore) Search(
	q store.Query) store.Result {

	return upperio.NewResult(func() (res db.Result, err error) {
		// get collection
		coll, err := s.Coll()
		if err != nil {
			return
		}

		// retrieve entities by given query conditions
		conds := upperio.Conds(q.GetConds())
		if conds == nil {
			res = coll.Find()
		} else {
			res = coll.Find(conds)
		}

		// add sorting information, if any
		res = res.Sort(upperio.Sort(q)...)

		// handle paging
		if q.GetOffset() != 0 {
			res = res.Skip(uint(q.GetOffset()))
		}
		if q.GetLimit() != 0 {
			res = res.Limit(uint(q.GetLimit()))
		}

		return
	})

}

// One returns the first Client matches condition(s)
func (s *ClientStore) One(
	c store.Conds, ep store.EntityPtr) (err error) {

	// retrieve results from database
	l := &[]Client{}
	q := store.NewQuery().SetConds(c)

	// dump results into pointer of map / struct
	err = s.Search(q).All(l)
	if err != nil {
		return
	}

	// if not found, report
	if len(*l) == 0 {
		err = store.ErrorNotFound
		return
	}

	// assign the value of given point
	// to the first retrieved value
	(*ep.(*Client)) = (*l)[0]
	return nil
}

// Update Client on condition(s)
func (s *ClientStore) Update(
	c store.Conds, ep store.EntityPtr) (err error) {

	// get collection
	coll, err := s.Coll()
	if err != nil {
		return
	}

	// get by condition and ignore the error
	cond, _ := c.GetMap()
	res := coll.Find(db.Cond(cond))

	// Marshal the item, if possible
	// (quick fix for upperio problem with db.Marshaler)
	if me, ok := ep.(db.Marshaler); ok {
		ep, err = me.MarshalDB()
		if err != nil {
			return
		}
	}

	// update the matched entities
	err = res.Update(ep)
	if err != nil {
		err = s.errorf("Error updating Client: %s", err.Error())
	}
	return
}

// Delete Client on condition(s)
func (s *ClientStore) Delete(
	c store.Conds) (err error) {

	// get collection
	coll, err := s.Coll()
	if err != nil {
		return
	}

	// get by condition and ignore the error
	cond, _ := c.GetMap()
	res := coll.Find(db.Cond(cond))

	// remove the matched entities
	err = res.Remove()
	if err != nil {
		err = s.errorf("Error deleting Client: %s", err.Error())
	}
	return nil
}

// AllocEntity allocate memory for an entity
func (s *ClientStore) AllocEntity() store.EntityPtr {
	return &Client{}
}

// AllocEntityList allocate memory for an entity list
func (s *ClientStore) AllocEntityList() store.EntityListPtr {
	return &[]Client{}
}

// Len inspect the length of an entity list
func (s *ClientStore) Len(pl store.EntityListPtr) int64 {
	el := pl.(*[]Client)
	return int64(len(*el))
}

// Coll return the raw upper.io collection
func (s *ClientStore) Coll() (coll db.Collection, err error) {
	// get raw collection
	coll, err = s.Db.Collection("oauth2_client")
	if err != nil {
		err = s.errorf("Error connecting collection oauth2_client: %s",
			err.Error())
	}
	return
}

// SetLogger set the logger fotr the ClientStore
func (s *ClientStore) SetLogger(logger log.Logger) {
	s.logger = logger
}

// Log logs the message with session id
func (s *ClientStore) error(msg string) error {
	serr := store.ErrorInternal
	serr.ServerMsg = msg
	s.logger.Log("store", "ClientStore", "message", msg)
	return serr
}

// Logf logs the message with session id
func (s *ClientStore) errorf(msg string, v ...interface{}) error {
	return s.error(fmt.Sprintf(msg, v...))
}

// Close would not close database connection at all.
// Please use store.CloseAllIn(ctx) to wrap up connections
// in a context
func (s *ClientStore) Close() error {
	return nil
}
